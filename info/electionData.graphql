enum AdminLevel {
  BASIC # basic admin - can view current and archived election results
  OFFICIAL # election official - can update their details and trigger an election recount
  ELECTION
  RULE
  SUPER
  ROOT
}

enum DataType {
  STRING
  INTEGER
  DATE
  DATETIME
  BOOLEAN
}

enum EmailType {
  INVITE TO NOMINATE
  REMINDER TO NOMINATE
  INVITE TO VOTE
  REMINDER TO VOTE
  VIEW RESULTS
}

enum ElectionStatus {
  PENDING
  TAKING NOMINATIONS
  CAMPAIGNING
  VOTING
  COUNTING
  RESULTS
  ARCHIVED
}

enum EndormentStatus {
  REJECTED
  NONE
  REQUESTED
  VARIFIED
}

enum VoterCandidateStatus {
  DISQUALIFIED
  CANNOT_STAND
  ELIGIBLE
  IS_STANDING
  ELECTED
}

enum VoterStatus {
  FORBIDDEN
  ALLOWED
  VOTED
}

enum ElectionLogType {
  MESSAGE
  NOTICE
  WARNING
  ERROR
}

enum ElectionLogTypeSub {
  IMPORT
  EMAIL
  AUTHENTICATION
  NOMINATION
  VOTE
  VALIDATION
  COUNT
}

enum SystemLogType {
  INSERT
  UPDATE
  DELETE
}

interface ElectionOption {
  id: ID!
  name: String!
  description: Markdown!
  extraInfoURL: URL

}

# ===============================================

scalar Date
scalar DateTime
scalar Timestamp
scalar URL
scalar Email
scalar Markdown

# ===============================================

type Admin {
  id: ID!
  userID: String!
  cohortSource: CohortSource!
  authLevel: AdminLevel!
  positionTitle: String
  rules: [Rule]!
  elections: [Election]!
  created: DateTime!
  createdBy: Admin!
  updated: DateTime!
  updatedBy: Admin!
}

type Ballot {
  election: Election!
  ballotPaper: [BallotPaper]!
  hash: String!
}

type BallotPaper {
  ballotElection: Election!
  ballotPaper: [BallotPaperItem!]!
  ballotChecksum: String!
  ballotID: String
}

type BallotPaperItem {
  candidateID: ElectionOption!
  rank: Int!
}

type BasicUser {
  id: ID!
  userID: String!
  cohortSource: CohortSource
  fullName: String!
  email: String!
}

type BasicUserSimple {
  id: ID!
  fullName: String!
}

type BorderCountCandidate {
  candidate: ElectionOption!
  totalPoints: Float!
  rank: Int!
  countForRank: [BoderCountCandidateSub!]!
}

type BoderCountCandidateSub {
  position: Int!
  count: Int!
  positionValue: Float!
  totalPointsForPosition: Float!
}

type Candidate {
  id: ID!
  name: Voter.fullName!
  description: Markdown!
  extraInfoURL: URL
  photoURL: URL
  endorsedBy: Party
  created: DateTime!
}

type CandidateAll implements Candidate {
  id: ID!
  name: Voter.fullName!
  description: Markdown!
  extraInfoURL: URL
  photoURL: URL
  endorsedBy: Party
  endorsedByStatus: EndormentStatus!
  nominators: [Voter]!
  created: DateTime!
  updated: DateTime!
  updatedBy: Admin!
}

type changeLog {
  id: ID!
  time: Timestamp!
  changeBy: Admin
  action: SystemLogType!
  changeTable: String!
  diff: String!
}

type CohortFilter {
  id: ID!
  cohortSource: CohortSource!
  parameters: [KeyValuePair!]!
  enabled: Boolean!
  description: String!
  created: DateTime!
  createdBy: Admin!
  updated: DateTime!
  updatedBy: Admin!
}

type CohortSource {
  id: ID!
  name: String!,
  description: String!
  enabled: Boolean!
  availableParameters: [KeyValuePairOption!]!
  created: DateTime!
  createdBy: Admin!
  updated: DateTime!
  updatedBy: Admin!
}

type CountMethod {
  id: ID!
  name: String!
  officialName: String!
  description: String
  infoURL: String
  options: [KeyValuePairOption]!
  enabled: Boolean!
  created: DateTime!
  createdBy: Admin!
  updated: DateTime!
  updatedBy: Admin!
}

type Election {
  id: ID!,
  name: String!,
  description: Markdown!
  status: ElectionStatus!
  dates: {
    nominationsOpen: DateTime
    nominationsClose: DateTime
    votingOpen: DateTime!
    votingClose: DateTime!
    counting: DateTime!
  }
  year: Int!
  url: URL!
  rule: Rule!
  cohort: Cohort!
  isReferendum: Bool!
  returningOfficer: ElectionOfficial!
  contact: ElectionOfficial
  isReferendum: Bool!
  candidates: [Candidate]!
}

type ElectionFull implements Election {
  id: ID!,
  name: String!,
  description: String
  status: ElectionStatus!
  rule: Rule!
  cohort: Cohort!
  dates: {
    nominationsOpen: DateTime
    nominationsClose: DateTime
    votingOpen: DateTime!
    votingClose: DateTime!
    counting: DateTime!
    archive: DateTime!
  }
  returningOfficer: ElectionOfficial!
  contact: ElectionOfficial
  isPublic: Bool!
  candidates: [Candidate]!
  emails: [Email]!
  admins: [Admin]!
  created: DateTime!
  createdBy: Admin!
  updated: DateTime!
  updatedBy: Admin!
}

type ElectionLog {
  id: ID!
  time: Timestamp!
  election: Election!
  type: ElectionLogType!
  subType: ElectionLogTypeSub!
  code: Int!
  message: String!
}

type ElectionOfficial implements BasicUser {
  id: ID!
  fullName: String!
  positionTitle: String!
}

type ElectionOfficialAll implements ElectionOfficial {
  id: ID!
  userID: String!
  fullName: String!
  email: String!
  positionTitle: String!
  created: DateTime!
  createdBy: Admin!
  updated: DateTime!
  updatedBy: Admin!
}

type Electorate {
  voters: [Voter!]!
  page: Int!
  count: Int!
}

type Email {
  id: ID!
  election: Election!
  type: EmailType!
  subject: String!
  from: ElectionOfficial.email!
  body: String!
  isTemplate: Boolean!
  startSend: DateTime
  sendEnd: DateTime
  sendCount: Int!
  created: DateTime!
  createdBy: Admin!
  updated: DateTime!
  updatedBy: Admin!
}

type FirstPastCandidate {
  candidate: ElectionOption!
  totalVotes: Int!
  rank: Int!
}

type KeyValuePair {
  key: String!
  value: String|Int|Date|DateTime|Bool|[String]!
  dataType: DataType!
}

type KeyValuePairOption implements KeyValuePair {
  key: String!
  value: String|Int|Date|DateTime|Bool|[String]!
  dataType: DataType!
  default: String|Int|Date|DateTime|Bool!
}

type Party {
  id: ID!
  name: String!
  url: URL!
}

type PartyFull implements Party {
  id: ID!
  name: String!
  url: URL!
  created: DateTime!
  createdBy: Admin!
  updated: DateTime!
  updatedBy: Admin!
}

type ReferendumOption implements ElectionOption {
  id: ID!
  name: String!
  description: Markdown!
  extraInfoURL: URL
}

type ReferendumOptionFull implements ReferendumOption {
  id: ID!
  name: String!
  description: Markdown!
  extraInfoURL: URL
  created: DateTime!
  createdBy: Admin!
  updated: DateTime!
  updatedBy: Admin!
}

type Result {
  election: Election!
  winners: [Candindate!]!
  details: CountMethodResultDetails!
  totalVoters: Int!
  totalVotesCast: Int!
}

type CountMethodResultDetails {
  # see countMethod.graphql
  countType: String!
  results: [
    # see countMethod.graphql
  ]
}

type ResultDetailsMultiRound {
  options: [MultiRound!]
}

type ResultDetailsSingleRound {
  options: [SingleRound!]
}

type Rule {
  id: ID!
  name: String!
  description: String
  countMethod: CountMethod!
  countMethodOptions: [KeyValuePair]!
  durations: {
    nomination: Int!
    campaign: Int!
    voting: Int!
    results: Int!
  }
  winnerCount: Int!
  nominatorCount: Int!
}

type RuleAll implements Rule {
  id: ID!
  name: String!
  description: String
  countMethod: CountMethod!
  countMethodOptions: [KeyValuePair]!
  durations: {
    nomination: Int!
    campaign: Int!
    voting: Int!
    results: Int!
  }
  winnerCount: Int!
  nominatorCount: Int!
  admins: [Admin]!
  elections: [Election]!
  created: Timestamp!
  updated: Timestamp!
  createdBy: Admin.id
  updatedBy: Admin.id
}



type SentEmail {
  emailID: Email.id!
  sendTime: Timestamp!
  type: EmailType!
}

type TwoCandidatePreferred {
  round: [TwoCandidatePreferredRound!]
}

type TwoCandidatePreferredRound {
  candidates: [TwoCanidatePreferredCandidate!]
}

type TwoCanidatePreferredCandidate {
  round: Int!
  totalCount: Int!
  position: Int!
  eliminated: Bool!
}

type Voter implements BasicUser {
  id: ID!
  election: Election!
  userID: String!
  fullName: String!
  email: String!
  voted: Bool!
  voterStatus: VoterStatus!
  candidateStatus: VoterCandidateStatus!
  nominator: Bool!
  ballotChecksum: String
  sentEmails: [SentEmail]!
}
# ===============================================

union ElectionOption: ReferendumOption | Candidate

union MultiRound: TwoCandidatePreferred

union SingleRound: FirstPastCandidate|BorderCountCandidate
